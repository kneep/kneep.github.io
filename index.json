[{"content":"介绍 #从 本系列第二篇文章中我们可以看出，SC 这种内存模型，优点是符合直觉，符合直觉非常重要，它意味着写代码不容易犯错。但是，它同时又束缚了处理器设计者的手脚，无法运用可能的优化手段来提升处理器性能。\n本文中，我们来给 SC 稍微松松绑。什么情况下需要松绑呢？先来看下面的场景。 在这个场景中，core 0 将数据写入内存中，core 1 将数据从内存中读出。略有不同的是，在 core 0 和内存之间加了一个 write buffer。为什么要加这个缓冲？我们可以注意到，图中的内存系统写的是 Cache-Coherent Memory System，因为缓存的存在，多核处理器的缓存之间需要通过某种协议来确保所有处理器通过缓存看到的内存内容是一致且有效的，只有被写的地址的内容出于缓存一致（Cache-Coherent）的状态，写指令才能被执行。而实施这种缓存一致性协议是需要花费时间的，所以写指令经常需要等待。加了这个缓冲，处理器可以先把写指令提交到缓存中，等到它对应的地址处于一致状态时，再把写指令取出执行，提升了写的性能。\n但是，这也带来了副作用。因为数据从进入 write buffer 到出来，也是需要时间的。Core 1 同时在读内存的内容，如果它读取的内容与 core 0 写的内容无关，那么皆大欢喜。但如果 core 1 必须读到 core 0 刚刚写入的内容呢？这就有点复杂了。从图上可以看到，假设从上到下代表了时间轴，那么 core 0 的写操作虽然发生在 core 1 的读操作之前，但它写的内容真正进入内存，却发生在读操作之后。也就是说，core 1 没有读到它想要的值。更糟糕的是，程序员通常很难意识到这里有问题，因为它违反了直觉。\n同时，当读和写是操作同一地址的时候，无论写指令是否还在缓冲中，后面的读指令都能读到最新的值，这种现象称为 bypassing。\nTotal Store Order（TSO），我们要介绍的第二种内存模型，它和 SC 的主要区别就是允许上面这种特性带来的乱序。\n场景分析 #因为 TSO 的大部分特性和 SC 相同，我们仅仅讨论差别的两个特性：写读乱序、bypassing。\n场景一 #写读乱序我们继续使用 本系列第二篇文章中的例子，再次把伪代码列如下：\n// Core C1 S1: x = NEW; L1: r1 = y; // Core C2 S2: y = NEW; L2: r2 = x; 在场景四中，我们构造了如下的执行序列： 我们之前提到，因为S2 \u0026lt;p L2，但是同时L2 \u0026lt;m S2，所以它是不符合 SC 的。它造成了(r1, r2) == (0, 0)这个非常不符合直觉的结果。\n现在我们知道它的出处了，它就是我们上面分析的 write buffer 的场景，虽然不符合 SC，但它是符合 TSO 的。S2: y = NEW;这个写操作虽然是最早发生（更准确地应该称为「提交」），但因为 write buffer 的存在，它的生效发生了延迟。\n场景二 #下面我们为 TSO 构造了一个更复杂点的例子来说明 bypassing：\n// Core C1 S1: x = NEW; L1: r1 = x; L2: r2 = y; // Core C2 S2: y = NEW; L3: r3 = y; L4: r4 = x; 程序运行后，有没有可能(r1, r3) == (NEW, NEW)且(r2, r4) == (0, 0)？ 答案是有可能。 从这个执行序列可以看出，r1能得到NEW值，哪怕NEW尚未实际进入x的内存位置，原因就是这两条指令操作的是同一地址，存在 bypassing 效应，红点即为 bypassing 发生处。同理r3也一样。\nbypassing 是符合直觉的，因为我们直观上认为，同一处理器写出去的值，无论是否真正进入内存，处理器自己理应知道最新的值。就像你可以欺骗别人，但骗不了自己。\n形式化定义 #我们在 SC 的形式化定义基础之上，看看 TSO 的定义有什么区别。\n所有处理器按照它们的\u0026lt;p把读（Load）写（Store）指令插入到\u0026lt;m中，不管这些指令是否针对同一内存地址（a == b 或 a != b 都适用），具体包括四种情况： 如果 L(a) \u0026lt;p L(b)，则 L(a) \u0026lt;m L(b)（Load -\u0026gt; Load） 如果 L(a) \u0026lt;p S(b)，则 L(a) \u0026lt;m S(b)（Load -\u0026gt; Store） 如果 S(a) \u0026lt;p L(b)，则 S(a) \u0026lt;m L(b)（Store -\u0026gt; Store） 如果 S(a) \u0026lt;p L(b)，则 S(a) \u0026lt;m L(b)（Store -\u0026gt; Load） 变更一：Write Buffer 效应，使 Store -\u0026gt; Load 的顺序无法保证 针对同一内存地址，读（Load）会得到 \u0026lt;m 中最近一次写（Store）的值，或者同一处理器上一个尚位于 Write Buffer 中的值： L(a) = Max\u0026lt;m { S(a) | S(a) \u0026lt;m L(a) } 或 S(a) \u0026lt;p L(a) S(a) \u0026lt;p L(a)是指针对同一地址的最新一个写指令。 变更二：对地址a的Load，要么读到\u0026lt;m中的最新值，要么读到\u0026lt;p中的最新值，而且后者优先。 引入新的FENCE指令，其特性满足以下规则： 如果 L(a) \u0026lt;p FENCE，则 L(a) \u0026lt;m FENCE （Load -\u0026gt; FENCE） 如果 S(a) \u0026lt;p FENCE，则 S(a) \u0026lt;m FENCE （Store -\u0026gt; FENCE） 如果 FENCE \u0026lt;p FENCE，则 FENCE \u0026lt;m FENCE （FENCE -\u0026gt; FENCE） 如果 FENCE \u0026lt;p L(a)，则 FENCE \u0026lt;m L(a) （FENCE -\u0026gt; Load） 如果 FENCE \u0026lt;p S(a)，则 FENCE \u0026lt;m S(a) （FENCE -\u0026gt; Store） FENCE的原意是「栅栏」，这是一个非常形象的词汇，它的作用是代码执行序列分割成上下两部分，上半部内部，顺序无法保证，下半部内部，顺序也无法保证。但是，上半部的指令一定会在下半部的指令之前生效。\n由于 TSO 只破坏了一条 SC 的规则，它实际只需要规则 2 和 4 就可以了。但为了方便后续学习更多的内存模型，我们把完整的 FENCE 规则都放在这里。\nLoad 2 Store 2 RMW 2 FENCE 2 Load 1 Yes Yes Yes Yes Store 1 B Yes Yes Yes RMW 1 Yes Yes Yes Yes FENCE 1 Yes Yes Yes Yes 粗体的字代表了 TSO 相对 SC 变化的点，其中 B 代表了：针对同一内存地址的Store-\u0026gt;Load的需要 bypassing，其他情况则顺序无法保证。\n在第一个场景中，我们看到结果可能出现(r1, r2) == (0, 0)，现在我们来看下，有了FENCE指令后，如何确保这个有违直觉的结果不再出现。\n// Core C1 S1: x = NEW; FENCE; L1: r1 = y; // Core C2 S2: y = NEW; FENCE; L2: r2 = x; 在这里，FENCE强制了S1-\u0026gt;L1和S2-\u0026gt;L2的顺序，使得(r1, r2) == (0, 0)不会再出现。\n总结 #SC 是最符合直觉的内存模型，TSO 也接近直觉，它能提供更好的性能，代价是无法保证Store-\u0026gt;Load的顺序，程序员必须意识到这里需要FENCE，没有系统学习过这个主题的程序员很容易在这里犯错。\n据信，Intel 和 AMD 的 x86 处理器用的内存模型是 TSO。\n","date":"三月 15, 2025","permalink":"/posts/memory-model/total-store-order/","section":"文章","summary":"","title":"【内存模型】TSO"},{"content":"","date":null,"permalink":"/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/","section":"标签","summary":"","title":"工程实践"},{"content":"","date":null,"permalink":"/series/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","section":"系列","summary":"","title":"内存模型"},{"content":"","date":null,"permalink":"/","section":"尼普学种花","summary":"","title":"尼普学种花"},{"content":"行程 #本次旅程的进出点都是澳大利亚的第二大城市、维多利亚州首府——墨尔本（Melbourne），所以路线尽量走环线。\n旅程从墨尔本南面一点的小镇「托尔坎（Torquay）」开始，沿着举世闻名的「大洋路（The Great Ocean Road）」西行，走完后北上进入格兰坪山区，在「格兰坪国家公园（Grampians National Park）」进行徒步探索后，转向东行，经过淘金时代的古老城市「本迪戈（Bendigo）」，到达维州东部高山区的门户市镇「旺加拉塔（Wangaratta）」，再一路南下，穿越著名的「大高山路（The Great Alpine Road）」，到达南部小镇「佩内斯维尔（Paynesville）」，随即乘渡船到「雷蒙德岛（Raymond Island）」，寻觅野生考拉的足迹，从岛上出来后，一路西行，最后到达小镇「福斯特（Foster）」，澳洲大陆最南端的「威尔逊岬角国家公园（Wilsons Promontory National Park）」位于此处，徒步一日后，继续西行到达「莫宁顿半岛（Mornington Peninsula）」，此处已接近墨尔本，徒步「内皮恩角国家公园（Point Nepean National Park）」，直到半岛的尖尖角上，最后留给墨尔本三天，City Walk 游览市区殖民时代的华美建筑，参观美术馆，体验当地美食，造访全澳顶级学府墨尔本大学，旅程到此结束。 Day 0：到达 #航班到达墨尔本的时间很棒，下午两点多。上次去新西兰，出关排了一个多小时，这次特地约了落地两小时后取车，结果出关特别顺利。大人直接用电子护照出关，全程没人问，小孩不行，需要有一个大人带着去窗口，但也没人排队，象征性问了两句话，就让走了。飞机落地到出机场，只用了四十五分钟。 这次租车的车行是「Budget」，虽然名字有点寒酸，但是好歹是国际大牌连锁。取车总体很快，提早了一个小时提车，也没为难我。但接待员反复警告我，如果去雪山，需要买额外保险，否则出问题不保。我反复想了下，嗯，冒个险吧。 租的车是混动凯美瑞，2023 款，很新，而且超级省油。从国内带了一个十几块钱的、能夹在仪表盘屋顶的万向手机夹，非常稳固。拿了车，直接向晚上住的地方出发了。 当天的目的地是「托尔坎（Torquay）」，位于大洋路起点的小镇。住托尔坎，主要是希望一天内走完大洋路，在墨尔本落地时间，也很适合当天再驱车一个多小时。小镇就两三家汽车旅馆，条件比较简陋，预定了其中一家，就是睡个觉。吃饭比较难，找了家泰餐馆解决。\nDay 1：大洋路 #早上从托尔坎出发，开始一天走完大洋路的挑战。网上的攻略，一般都是建议两三天，当然里面包括了各种游乐项目，以及来回墨尔本的时间。如果不走回头路，而且以看路上的风景为主，一天是够的。 第一个值得看下的地方是这个灯塔，免费的，叫「Split Point Lighthouse」。可以开车上去，停车场在离灯塔不远的地方，走到灯塔五分钟，注意不要打扰灯塔旁边的住户。灯塔背后还有一条很短的步道，可以走到临海的悬崖边上，俯瞰海景以及被腐蚀的山岩。 接下来就来到这个大洋路的纪念门廊，路边有停车场以及纪念碑，讲述了大洋路修建的背景。大洋路始建于 1919 年，在 1932 年竣工，澳大利亚政府借此纪念第一次世界大战中牺牲的人。拍个照继续前行。 在途径的小镇「阿波罗湾（Apollo Bay）」附近，有一条步道值得一走，地图上搜「Marriner\u0026rsquo;s Lookout」，开车上去，最后一段需要步行。 登顶后可以俯瞰整个阿波罗湾。整个来回，包括步行、拍照，一个小时足够了。 阿波罗湾是大洋路上的一个重要补给站，设施比较完善，有不少人选择在这住一晚。中饭就在阿波罗湾解决了，英式垃圾食品的王者——炸鱼薯条，好香。 午饭后，大洋路暂别了沿海路段，进入内陆。虽然是冬天，牧场的草还是鲜绿的。等再次回到沿海，大洋路就进入精华的路段了。 吉布森海滩（Gibson Beach）是一片非常干净的海滩，把车停好沿着台阶走下悬崖，水很蓝，海边有很多呆萌的海鸥，浪一来就散开，浪一走就聚拢。 再往前走就是最著名的「十二使徒（Twelve Apostles）」了，矗立在浅滩中的岩柱，让海风吹拂了千万年。这里有游客中心，有很大的停车场，因为所有人来大洋路都要来看这个景点，设施比较完善。 十二使徒再往前走，几个著名的景点都是形态各异的岩柱，没必要每个地方都去，看多了会审美疲劳。这两张是在「沉船谷（Loch Ard Gorge）」拍的。 这里叫「伦敦桥（London Bridge）」，确实有点像桥，无法反驳。\n看完这里，就到傍晚了，下一站就是终点「瓦南布尔（Warrnambool）」。到瓦南布尔的时间大约是七点不到，因为是冬天，天已经完全黑了。汽车旅馆的前台早就下班，打了电话过去，告知如何自助取钥匙入住。晚饭在镇上找了一家西餐馆吃了晚饭。\n看起来一天内走完大洋路完全是可以的。早上八点从托尔坎出发，也不算特别早，晚上七点前到瓦南布尔，也不算特别晚。精华路段也都没错过，该停留的也都停留了。驾驶强度略高，全程有美景相伴。今天是阴天，部分路段下了点小雨，除了十二使徒，其他地方游客很少，体验还是不错的。\nDay 2：瓦南布尔→霍斯盖普 #第二天从瓦南布尔开始往北走，目的地是「霍斯盖普（Halls Gap）」。霍斯盖普是「格兰坪国家公园（Grampion National Park）」区域的一个小镇，来国家公园的人一般都住这里。今天的驾驶强度比较低。 早上起来，外面刚刚下完雨，空气很清新，出发前先在住处隔壁的一个小公园散了一会儿步。从霍斯盖普到格兰坪路不长，一路上以田园风光为主，没有什么特别惊艳的地方。中午就到霍斯盖普了。\n我们在这次旅行中，很多晚都住在「Holiday Park」这种住宿地，「Holiday Park」在澳洲很常见，俗称「大篷车公园」，通常是一个开放的营地，里面基本都是独立的小屋，小屋外表看起来有点像那种集装箱。小屋有各种规格，有些提供完整的厅、房间、厨卫，床通常是一个双人大床再加一些上下铺的单人床，这对多个孩子的家庭出游很友好，两个大人睡大床，孩子每人一个单床；还有些小屋只提供盥洗功能，主要给房车用户过夜使用。 我们住的这个营地，最大的特色就是满地是袋鼠，当然也有满地的袋鼠屎，有时候袋鼠就躺在你小屋的门口。 格兰坪有很多徒步路线，因为当天入住后时间还早，先选了一条较短的路线走了一圈热热身。 霍斯盖普整个镇上只有一家简陋的超市，餐厅也非常有限，很多冬季都不开。我们驱车十几公里去隔壁镇上的大超市买了食材，澳洲啥都贵，但奶制品和肉便宜，自己做了饭，幸福感满满。\nDay 3：格兰坪国家公园 #今天的主题是徒步。我们选了格兰坪国家公园最著名的一条步道「The Pinnacle Walk」，走了一个最大的圈。如果接近中午的时候出去，差不多吃完饭的时间回来。 临走前，看到路边的袋鼠，忍不住又上去撸了一把。 这条步道以石头山石头路为主，越到上面，越有意思，各种怪石中找路。步道挺人性化，在有岔道的地方，一般都会有路标。 登顶后，有几个伸出到半空中的石头平台，上面视野非常棒，可以远眺整个格兰坪山区，而山下就是霍斯盖普。下山有多条路，建议下去的时候选另外一条路，走个环线，风景不重复。 回到营地，正好晚饭时间，继续吃自己做的饭，量大管够。 霍斯盖普也挺适合看星星。天黑后，在营地上空可以清晰地看到银河和南十字星。\nDay 4：瓦南布尔→本迪戈→旺加拉塔 #今天我们要一下从环线的最西边到最东边。东边的「旺加拉塔（Wangaratta）」是「大高山路（The Great Alpine Road）」北部门户。从北到南穿越大高山路，一般都会从旺加拉塔出发。我们预定晚饭时分到达。中途经过的大片区域，是维多利亚州所谓的「金矿区」。十九世纪五十年代，受美国加州影响，维多利亚州也点燃了淘金潮，在之后的几十年中，淘金潮造就了维州经济的飞速发展、空前繁荣，也奠定了墨尔本在整个澳洲殖民地的核心地位，并成为澳大利亚建国前的临时首都。今天的旅途中，我们路过著名的淘金城市「本迪戈（Bendigo）」。 第一站是本迪戈的地标建筑，「圣心大教堂（Sacred Heart Cathedral）」，全澳第三大的教堂。它是对游客开放的，可以进内部游览，内部墙上挂有一系列表现耶稣受难过程的画作值得一看。 从圣心大教堂一路步行，经过了游客中心，它的前身是本迪戈邮局。 再到「罗沙林公园（Rosalind Park）」，公园不大，位于城市中心，里面有个瞭望台，可以俯瞰整个本迪戈市，遗憾的是没开放。这是位于公园内的一所学校，古色古香的房子。 最后是罗沙林公园外面的本迪戈美术馆。本迪戈不大，市区值得一看的地方，基本都是步行距离。我们大约下午两点左右离开本迪戈。 傍晚到了旺加拉塔，照例超市买食材，做饭^_^。\nDay 5：旺加拉塔→大高山路→佩内斯维尔 #今天就要穿越大高山路了。其实冬天不是穿越的好季节，但这个季节，似乎从北到南也没有什么其他靠谱的路，很多路段都是季节性封闭。冬季穿越大高山路，必须带雪链，这是维州政府要求的，因为山上的路段随时有可能下雪。我是在Hoys Skis租的，它家的好处就是可以异地归还，并且有流动服务车帮你免费安装雪链。Hoys Skis 的两个服务点分别在「哈里特维尔（Harrietville）」和「奥米欧（Omeo）」，大高山路上的两个小镇，一北一南，它们之间就是必须携带雪链的路段，两个方向都能异地取还，还是挺方便的。 我们从北到南走，先到哈里特维尔租雪链。一路上云山雾罩，天气不是很好。很多游客都在哈里特维尔租雪链，这里是进山前的最后一个补给站。我租的时候问了一下，工作人员答复当前山上的情况是需要装雪链的。店员给了一张地图，上面指明了装雪链的点（现在不能装，会损坏轮胎），说流动服务车会在那等。当我们到了雪链安装点后，好多游客都停车在那，但没有看到 Hoys Skis 的流动服务车。只能自己上啦。 在小红书上一顿学习，居然成功装上了，而且装得还挺像样。刚装完雪链，来了一辆貌似管理当局的车，告知我们山上路况不需要上雪链，要拿下来。好不容易装上，蹭了两手油污，现在要拿下来。还好此时 Hoys Skis 的流动服务车终于出现了，把卸雪链的事情交给他们了，租金已经付了，好歹享受一次服务吧。 山上有大雾，风景也看不到，只能下来玩了一会儿雪，略有点失望地离开了。 下山路上，出了浓雾区，风景倒是好起来了。 路遇不幸的袋熊，身上被画了一个十字架，愿它安息。 傍晚到达「佩内斯维尔（Paynesville）」，一个安静的小港口，今晚换下口味，不住大篷车公园了。 酒店就位于湖边，条件很不错，房间开门就是湖，湖里有好几只漂亮的黑天鹅。欧洲人一直认为天鹅只有白色，直到他们在澳洲看到了黑色的天鹅，从此赋予了「黑天鹅」一词全新的意义。\n晚上没有自己做饭，因为酒店一般只有微波炉，不像大篷车公园厨房设备很齐全。去了一家当地的俱乐部餐厅吃了西餐，喝了葡萄酒。顾客都是当地悠闲的老年人，有说有笑，聊得很放松，好像只有我们一家是游客。可惜忘了在那里拍照了。\nDay 6：雷蒙德岛→福斯特 #我们在佩内斯维尔落脚，最重要的原因是为了去对岸的「雷蒙德岛（Raymond Island）」看野生考拉。雷蒙德岛是维州最有名的野生考拉观赏地之一，它和佩内斯维尔隔一条狭窄的水道，有免费轮渡来往两边，单程只要三分钟左右，而且是免费的。早上退房后，我们先把车停到酒店对面的免费停车场，步行岛渡口搭乘轮渡上岛。上岛之前，酒店前台给了我们一张地图，并且把考拉的聚集点都给我们圈出来了，按图索骥就好了。 桉树是一种叶子稀疏的树种，很难看。考拉在桉树上，远远看去就是黑黑的一大坨毛球，在稀稀拉拉的树叶中很显眼，我们前后共找了二十只。 如果要好好观赏考拉的表情，就要带长焦镜，手机拍出来的效果就很一般了。 这户民居门口的树上就有两只（图中只拍到一只），爬得很低，这是我们找到的观察考拉最近的地方。 雷蒙德岛也是一个徒步的好地方，海边的景色很美。 从雷蒙德岛回来，取车，下午是比较长的路，我们要在傍晚赶到福斯特，一路上又是田园风光。\nDay 7：威尔逊岬角国家公园 #「威尔逊岬角（Wilsons Promontory）」是澳洲大陆的最南端，它是一个伸入大海的半岛，隔着巴斯海峡（Bass Strait）和塔斯马尼亚隔海相望。威尔逊岬角国家公园狭长，南北延伸，它的核心区域是没有住宿地方的，一般会住在北部的几个小镇，「福斯特（Foster）」是其中一个。 早上从福斯特出来，一路往南开，进入威尔逊岬角国家公园。第一个停留的景点是一个山顶的白沙漠，名字叫「Big Drift」，据说是网红景点。在停车场停好车，先要走大概二十分钟的步道，才能到达山顶的沙漠。山顶的景色很惊艳，很适合拍照。山顶风巨大，光靠风吹，就能把你的鞋子里面吹得到处是沙子。 第二站直接开到了主干道尽头的「奥伯伦山（Mount Oberon）」脚下，登山的步道比较长，七公里左右，对体力有点挑战，而且因为道路左右两侧被山体和高大的树木遮挡，过程略显枯燥。 但登上了山顶，天地豁然开朗，威尔逊岬角的雄伟海岸尽收眼底，一切都是值得的。 从山上下来，开始沿着主干道往回走，国家公园内有好几个海滩，我们选了一个叫「吱吱海滩（Squeaky Beach）」的去看了一下。沙子踩起来吱不吱我不知道，但这两块石头挺有意思的。海滩出来，天色已近黄昏，最后一站，我们决定去「野生动物步道（Wildlife Walk）」。步道的入口并不好找，在一大片草地的最里侧。 在步道门口的马路对面，我们终于看到了活着的袋熊。它很警觉，我们走过去，它就窜入了草丛里，只拍到一个屁股。 步道是一条环线，大概需要四十五分钟走完。里面有很多袋鼠和几只大鸟，但再也没遇到我们心心念念的袋熊了T_T。 走完步道天色已晚，回福斯特又是一顿操作^_^，吃得十二分饱。\nDay 8：福斯特→莫宁顿半岛 #今天的目的地是「莫宁顿半岛（Mornington Peninsular）」，它是墨尔本东南方的度假胜地，离威尔逊岬角不算远。到澳洲以来，虽然晴天几乎没有，但今天是第一次遇到下大雨，本来准备先到酒店入住，然后再逛半岛，因为天气原因，不知道该去哪了。在去莫宁顿半岛的路上，我们路过了「月光野生动物园（Moonlit Sanctuary Wildlife Conservation Park）」，临时决定进去参观。动物园很小，动物也不多，有些可能是下雨躲起来了，但是好在有呆萌的考拉，还可以去摸。 门口有动物饲料卖，可以买了喂袋鼠。 各种呆鸟挺多的。 我们参加了动物园的摸考拉。工作人员要花很大力气，不停地用桉树叶引诱考拉从树上下来，最后被装进一只笼子，整个过程非常有意思。和考拉合影的时候，工作人员必须给考拉手里塞一捧桉树叶，让它专注于吃，以免惦记身边抚摸它的游客。\n动物园出来，还在下大雨，到了酒店稍事休整，晚上出去吃了肯德基。\nDay 9：莫宁顿半岛 #我们住的地方叫「玫瑰花蕊（Rosebud）」，这是莫宁顿半岛的中心城镇。 早上起来，穿过静谧的居民社区，来到玫瑰花蕊海滩。 这个据说叫「果冻海」，确实有那么点像吧。 伸入海里很长的码头，有不少老年人在这里遛狗、散步。随着离岸距离的变化，海水的颜色也在变化。\n海边回来，我们临时决定去内「皮恩角国家公园（Point Nepean National Park）」。打开地图一看就明白，莫宁顿半岛非常狭长，它的最外端的顶点，就是内皮恩角。内皮恩角国家公园禁止私家车入内，需要找到比较近的停车点，然后步行入内。 内皮恩角只有一条狭窄的主干道，一路走到黑就行。朝着大海的方向行进，你的左侧是波涛汹涌的巴斯海峡，右侧是风平浪静的菲利普湾，形成了有趣的对照。路上还遇到了澳大利亚前总理「哈罗德·霍尔特（Harold Holt）」的纪念碑，1967 年 12 月 17 日，他从这里下水游泳，便消失于大海，遗体至今未找到，成为一桩离奇的悬案。 走到地图的尖尖头上，是英军留下的军事要塞。到了角上，就原路返回。\n离开莫宁顿半岛，经过一个多小时的驾驶，我们终于缓缓驶入墨尔本市区。经历了近十天的农村生活，到墨尔本，感觉一下子活过来了。墨尔本的住宿市场竞争就非常激烈，选择也很多，像冬天这样的淡季，在郊区住大篷车公园的钱，Airbnb 上可以找到品质挺不错的公寓。 我们住在 QV 商圈楼上的公寓，窗外就是墨尔本中央商务区的璀璨夜景。\nDay 10：墨尔本 #今天的任务是逐一打卡墨尔本市区的精华景点。我们公寓对面就是维多利亚州立图书馆，先从这里开始。 这个六角形的主厅，超级像去年在马来西亚哥打巴鲁看到的大巴刹。 中途路过皇家墨尔本理工大学的主楼，位置太好了，就在图书馆对面。 澳新银行，它其实是一个博物馆，里面有一些历史展品，可以进去逛逛。 历史悠久的弗林德斯街车站，竣工于 1909 年，墨尔本的地标。 弗林德斯街车站对面，就是另一个地标：圣保罗大教堂，可以入内参观。 教堂隔壁的涂鸦街，路过一下吧，没有太大兴趣。以上景点，半天基本就能徒步走下来。下午的重点是南岸地区的维多利亚国立美术馆。 步行跨过雅拉河，来到南岸的美术馆门口。门口竖着一个很夸张的拇指雕塑。维多利亚国立美术馆的藏品非常丰富，尤其是欧洲的绘画，其中不乏一些名家的作品。 毕加索。 莫奈。 马奈。\n对艺术品感兴趣的同学，完全可以在这里待一整天，因为光参观常规的绘画作品展厅，就花了我们一个下午，其他展馆根本来不及看。 从国家美术馆出来，继续往南步行，到了今天最后一站：国家战争纪念馆。纪念馆展品讲述了澳大利亚军人在历史上参与的各次战争，表彰他们为国家做出的牺牲。同一历史事件，在每个国家都有不同叙事，不要太在意。纪念馆的顶楼可以上去，在上面可以看到远眺墨尔本市区。 晚上维多利亚市场大快朵颐^_^。\nDay 11：墨尔本 #今天的主题是墨尔本大学。来到一个陌生的大城市，大学是我们必去的地方。墨尔本大学是全澳最顶尖的学府之一，它位于墨尔本北部的卡尔顿，离中央商务区不算远，慢慢走，一边走一边看。 大学是开放式的，没有围墙。大学入口处的一座小红楼。 校园内的咖啡，比外面便宜很多。 宁静的校园和远处的钟楼。 拱廊，跟斯坦福那个有点像，但小很多。 在操场远望墨尔本中央商务区。从这个操场旁边的小路再往北走，就出了校园。 校园外面穿过一条马路，就是历史悠久的「墨尔本公墓（Melbourne General Cemetery）」。逢墓必看的我好兴奋。公墓的门房就是一座很大的别墅，看起来也有点历史了。 公墓里有一个特别的庭院——总理墓园，多位澳大利亚前总理安息于此，包括在位时间最长的「罗伯特·孟席斯爵士（Sir Robert Menzies）」，还有前面提到的、消失于大海的那位的纪念碑。\n从墓园出来，已经是下午了，饥肠辘辘。墨尔本大学所在的卡尔顿是意大利移民和后裔的聚集区，特别出名的意大利美食，实在不能错过。 这是卡尔顿非常有名的一家意大利餐厅，已经过了饭点，上座率还很高。三个人居然吃了那么多。\n从卡尔顿回来，傍晚的时间留给了买伴手礼。\nDay 12：回家 #今天傍晚要启程回国了，但上午还是想找个地方再玩一下。端详了地图后，去了墨尔本南郊的「王子码头（Princes Pier）」。这个地方号称是摄影圣地。 主要就是看这些木桩子。水是碧绿的，桩子上面泛白，下面泛黄，搭配起来挺诡异的画面。\n从王子码头回来，看看还有点时间，于是临时决定去维多利亚市场吃最后一顿，顺便逛一下前一晚没去的那些店，反正都是朝北走。 吃了生蚝和虾。生蚝是生吃，其实没什么好吃的，除了海水咸咸的味道，没有其他味道。 最后看一眼糖果色的中央商务区，开车向机场驶去。\n费用 #以下是三口之家 12 天的主要花费项：\n项目 费用（人民币） 机票 7028 住宿 9182.27 签证 2754.04 吃饭 9236.16 租车 3160 加油 1000 没有算给朋友带的礼物，以及一些杂项的小费用。\n","date":"七月 28, 2024","permalink":"/posts/australia-2024/","section":"文章","summary":"","title":"2024 澳大利亚之行"},{"content":"","date":null,"permalink":"/tags/%E6%97%85%E8%A1%8C/","section":"标签","summary":"","title":"旅行"},{"content":"本文介绍第一种内存模型 SC，它是最符合直觉的内存模型，也是理解其他模型的基础。\n介绍 #SC 是「Sequential Consistency」的缩写，意思就是「顺序一致性」，后面我们提到它的时候，方便起见，后文均简称为 SC。它是 Leslie Lamport 在 1979 年发表的论文「How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs」中提出来的。Leslie Lamport 是一位了不起的计算机科学家，他更广为人知的成就是：一、因为在分布式系统方面的卓越贡献获得了 2013 年的图灵奖；二、LaTex 的作者。\n我们来看看 Leslie 是怎么说的：\n… the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.\n这句话够晦涩的，有一种「看不懂，但大受震撼」的感觉。我们来解构一下，有三个要点。\n程序执行是有某种全局顺序的。注意，这不是说多核上每次执行顺序都一样。\n在这种全局顺序中，每个处理器上的指令的执行顺序，跟单个处理器上程序指定的顺序一致。比如，在 本系列第一篇文章中的例子，C1上指定了先执行S1，后执行L1，那么，无论C1和C2并行执行最终会产生什么样的全局顺序，在这种全局顺序中，S1始终会在L1前面，但它们中间可能会插入别的处理器的指令。如果我们没有讲这个例子，那么这听起来就像一句废话，看了这个例子后再来看这句话，会发现它是值得深入思考的。\n言下之意，不同处理器之间的指令顺序，是无法保证的。也就是说，S1和S2谁先谁后，是不确定的。\n当然，这里既然讨论的是内存模型，那么，这些指令通常是跟操作共享内存有关的指令。如果不同处理器上的指令，不产生其他处理器能看到的效果，那么也就不在我们的讨论范围内了。\nSC 这种内存模型，是最符合大多数程序员直觉的。大多数程序员都觉得单核上的执行顺序应该跟程序指定的一样，然后多核之间的执行顺序是无法确定的。\n场景分析 #下面，我们基于上篇文章的伪代码来详细解释 SC：\n// Core C1 S1: x = NEW; L1: r1 = y; // Core C2 S2: y = NEW; L2: r2 = x; 说明如下：\nx 和 y 是共享内存中的变量 所有 r 是 CPU 本地变量（寄存器） L 和 S 代表读（Load）和写（Store） x、y 初始值都是 0 另外，我们要约定一些定义和助记符：\n程序指定内存操作在单个处理上的执行顺序——Program Order，记为\u0026lt;p 所有处理器的内存操作在内存中生效的顺序——Memory Order，记为\u0026lt;m op1在 Program Order 早于op2发生，记作op1 \u0026lt;p op2 op1在 Memory Order 早于op2发生，记作op1 \u0026lt;m op2 场景一 #第一个例子的执行如下图： 场景一 先来看两个处理器上的 Program Order 的情况：\n在C1 \u0026lt;p上的执行序列是S1-\u0026gt;L1，也就是说S1 \u0026lt;p L1 在C2 \u0026lt;p上的执行序列是S2-\u0026gt;L2，也就是说S2 \u0026lt;p L2 再来看实际产生的 Memory Order 的情况：\n最终体现在\u0026lt;m中的顺序为S1-\u0026gt;L1-\u0026gt;S2-\u0026gt;L2 意味着S1 \u0026lt;m L1，它和S1 \u0026lt;p L1是一致的 同时意味着S2 \u0026lt;m L2，它和S2 \u0026lt;p L2也是一致的 现在我们可以下结论： 场景一是符合 SC 的，运行结果是(r1, r2) == (0, NEW) 场景二 #第二个场景的执行如下图： 场景二 我们可以得出类似的结论：\n场景二是符合 SC 的，运行结果是(r1, r2) == (NEW, 0) 场景三 #第三个场景的执行如下图： 场景三 在这个例子中，在单个处理器上连续的指令，在实际执行的时候发生了交错（S1和L1之间隔着S2，S2和L2之间隔着L1），这在现实场景中很常见，但是如果我们对照 SC 的特性，依然可以得到以下结论：\n场景三是符合 SC 的，运行结果是(r1, r2) == (NEW, NEW) 场景四 #最后一个场景的执行如下图： 场景4 这个场景就有点不一样了，因为S2 \u0026lt;p L2，但是同时L2 \u0026lt;m S2，所以我们可以得出结论： 场景四是不符合 SC 的，运行结果是(r1, r2) == (0, 0) 形式化定义 #经过了这四个执行场景的分析，是时候给 SC 下一个形式化定义了。所谓形式化定义，就是用类似数学符号的语言，做逻辑严密的定义。\n所有处理器按照它们的\u0026lt;p把读（Load）写（Store）指令插入到\u0026lt;m中，不管这些指令是否针对同一内存地址（a == b 或 a != b 都适用），具体包括四种情况： 如果 L(a) \u0026lt;p L(b)，则 L(a) \u0026lt;m L(b)（Load -\u0026gt; Load） 如果 L(a) \u0026lt;p S(b)，则 L(a) \u0026lt;m S(b)（Load -\u0026gt; Store） 如果 S(a) \u0026lt;p L(b)，则 S(a) \u0026lt;m L(b)（Store -\u0026gt; Store） 如果 S(a) \u0026lt;p L(b)，则 S(a) \u0026lt;m L(b)（Store -\u0026gt; Load） 针对同一内存地址，读（Load）总是能得到 \u0026lt;m 中最近一次写（Store）的值： L(a) = Max\u0026lt;m { S(a) | S(a) \u0026lt;m L(a) } 上面公式的意思是，对地址a的Load，读到的是在\u0026lt;m中最新（Max）的一个对a进行Store的效果。\n此外，这里除了Load和Store，我们要引入第三种读写指令——RMW。RMW代表Read-\u0026gt;Modify-\u0026gt;Write，它通常用于这样一种场景：基于内存中某个变量的当前值来更新这个变量，比如把某个变量++。通常，做这样的操作，需要三个步骤：\n把内存的值读到寄存器中； 对寄存器中的值进行运算； 把新的值写回内存。 这三个步骤通常就是三条指令，所以这个过程是可以被打断的，从而产生「条件竞争」。而RMW是一类「原子操作」，所谓「原子操作」是指不能再分的操作，它把这三个步骤用一条指令完成了，从而避免了「条件竞争」。我们把RMW指令加入考虑，加上Load和Store，如果这三种指令中任取两个，分别记作op 1和op 2，且op1 \u0026lt;p op2，那么下面表格中的Yes就代表了op1 \u0026lt;m op2成立的场景（本系列文章中都会采用这种记法，不再赘述）：\nLoad 2 Store 2 RMW 2 Load 1 Yes Yes Yes Store 1 Yes Yes Yes RMW 1 Yes Yes Yes 当然，我们已经很清楚，对于 SC 这种模型来说，每种组合都是Yes。好像没什么特别的，但我们后面会介绍更多的内存模型，都是使用这种分析方法，并以 SC 为参照对比，所以首先理解 SC，是理解其他内存模型的基础。\n","date":"五月 10, 2024","permalink":"/posts/memory-model/sequential-consistency/","section":"文章","summary":"","title":"【内存模型】SC"},{"content":"讨论编程问题的时候，尤其是在并发编程的领域，我们经常看到会「内存模型」这个词，英语通常叫「Memory Model」或「Memory Consistency Model」。理解「内存模型」究竟意味着什么，对于写出高效稳定的计算机程序至关重要。但是，理解「内存模型」并不是一件容易的事情。本系列文章的目的，希望能对「内存模型」这个概念，给出浅显易懂的解释。尤其是帮助在嵌入式开发领域的软件工程师理解、掌握工作中必须要用到的知识。\n本篇我们先从一个简单的问题开始，介绍内存模型的概念。\n// Core C1 S1: x = NEW; L1: r1 = y; // Core C2 S2: y = NEW; L2: r2 = x; 上面的代码采用了类似 C 语言的伪代码，呈现了在两个处理器核上运行的一些指令。对这里的一些符号和初始条件做一些说明：\nC1、C2 代表处理器核（Core） L1、L2 代表读指令（Load） S1、S2 代表写指令（Store） x、y 代表存储在共享内存中的变量 r1、r2 代表存储在处理器寄存器中的变量 所有变量的初始值都是 0 NEW 代表一个非 0 常量 （在系列的后面文章中，都会用类似的表示方法，出现时将不再对此赘述。）\n问题来了： 程序运行后，(r1, r2) 的值可能是 (0, 0) 吗？ 这个问题看似很简单，一般的推理是这样的：\nr1 == 0 意味着 y == 0 y == 0 意味着 y = NEW 尚未执行 所以 r2 = x 更不可能执行 所以 (r1, r2) == (0, 0) 是不可能的 这种推理是最符合直觉的，不过，它是正确的吗？答案是——取决于处理器的「内存模型」。上面的推理，其实是需要某种内存模型来保证的。我们最基本的直觉是——先执行的指令，其结果先「被看到」，在硬件层面保证这种关系是最简单的，写代码的人就可以少操心。但是，硬件实现者的手被束缚了。\n另一些内存模型下，(0, 0) 这个结果是可能出现的，因为部分内存模型允许重排符合规则的指令，比如这个执行序列：L1 → L2 → S1 → S2 。为什么部分内存模型会允许这样的执行序列呢？主要是为了让硬件的实现者有更大自由度，做更多的优化（优化的原理不是本文重点）。有人自由了，就有人会不自由。程序员感觉世界崩塌了，什么都不可信了。其实，没有完全崩塌，因为指令的重排并不是随机的，而是有一定规则的，并且，当我们识别到有程序需要保证先后顺序的时候，处理器也给了我们工具来实现。\n不过无论如何，我们需要学习规则，并使用工具，才能达到目的，编程确实变难了。\n到这里，我们对「内存模型」这个概念，已经有了一定的直观认识。对于这样一类程序：\n运行在某种 CPU 指令集上 在多个 CPU 上执行多个线程 多个线程对共享内存进行读写 我们会问：\n硬件的实现者可以对这些读写指令做哪些优化？规则是什么？ 软件的实现者可以信任哪些假设？不能信任哪些假设？如何来保证执行顺序？ 澄清以上问题的规则，构成了「内存模型」。「内存模型」让 CPU 设计者、编译器实现者、操作系统开发者、应用软件开发者等角色在统一的规则下工作。\n从下一篇开始，我们会逐个介绍几种主流的内存模型。\n","date":"五月 7, 2024","permalink":"/posts/memory-model/introduction/","section":"文章","summary":"","title":"【内存模型】什么是内存模型"},{"content":"原文地址：https://www.paulgraham.com/google.html\n本文是我给一群十四五岁的孩子做的演讲，有关如果他们以后想创业，现在该做点什么。很多学校认为该给学生讲讲创业公司。本文就是我认为该讲的内容。\n你们大多数人可能认为，当你们踏上社会，最后必须得找到一份工作。并非如此，今天我来聊聊一项技巧，能让你们免于找工作之苦。\n这项技巧就是创立自己的公司。所以，这项技巧并不是让你逃避工作，因为如果你创立了自己的公司，你会比在普通工作岗位上更加努力。但你却可以避免很多普通工作岗位上烦人的事情，包括对你发号施令的老板。\n做自己的项目，比给别人打工更激动人心。并且你也可能挣大钱。事实上，这是标准的致富之道。如果你看看偶尔见诸新闻的顶级富豪名单，几乎所有人都是创业致富的。\n从理发店，到谷歌，自己创立的公司不一而足。今天我在这想聊的是各色公司的极端。我来告诉你们如何创立谷歌那样的公司。\n谷歌这类公司刚创立时，叫做创业公司（startups）。我之所以了解它们，是因为我妻子杰西卡和我创立了一家叫 Y Combinator 的公司，它是一家创业孵化工厂。从 2005 年至今，它投资了超过 4000 家创业公司。所有我们很清楚创业需要什么，过去十九年以来，我们一直在帮他人创业。\n当我说我要告诉你们如何创立谷歌那样的公司的时候，你们可能认为我在开玩笑。你们可能会想，「我们怎么可能创立谷歌那样的公司呢？」当谷歌的创始人刚成立这家公司时，他们实际上也是这么想的。当你告诉谷歌的创始人拉里•佩奇和谢尔盖•布林，他们将要成立的公司有朝一日会达到万亿美元市值，他们是根本无法想象的。\n当你刚开始创业时，你只知道这件事值得去追求。你没法知道公司最终能到数亿市值，还是关门大吉。所以当我说我要告诉你们如何创立谷歌那样的公司的时候，我指的是，如何具备当时谷歌一样的潜质，能成为后来的谷歌。1\n从现在开始，你如何能创立一家成功的创业公司？你需要做三件事。你需要精通某种技术，你需要一个产品创意，你需要一起干的创业伙伴。\n如何精通技术呢？并且你应该去精通什么技术呢？这两个问题殊途同归：做你自己的项目。别想着猜基因编辑、大语言模型或火箭会不会成为最值得学的技术。没人能预测。做你最感兴趣的事。你喜欢做的事和你觉得你应该做的事，面对前者你会加倍努力。\n如果你不确定该去精通什么技术，那就精通编程。过去三十年，编程技术是典型的创业公司来源，未来十年很可能也一样。\n你们中在校学习计算机科学的人此时可能在想，好，我们已经搞定这事了。我们已经学会了编程。但是对不起，这还不够。你必须要做自己的项目，而不是仅在课堂上学点东西。你可能计算机科学课学得很好，但根本不会编程。事实上，你都可以在不擅长编程的情况下，在顶级大学拿到计算机学位。所以不管你上的哪所大学，成绩有多好，技术公司在录用你之前，都要求你做编程测试。他们都知道学校的考试成绩和等第说明不了什么。\n如果你真的想学编程，你必须得做自己的项目。这样会学得快很多。想象下你在开发一个游戏，想做某个功能，你不知道怎么做。但你很快会想办法搞清楚，比课堂上学任何东西都快得多。\n你也不一定要学编程。如果你想知道什么算是技术，你能用「做（make）」或「造（build）」来描述的所有东西实际上都算。所以，焊接算，做衣服、做视频都算。所有你感兴趣的事情。关键区别在于，你是在创造还是仅仅使用。你是在开发游戏，还是在玩游戏？这是界线。\n苹果创始人史蒂夫•乔布斯十几岁的时候学习了书法——那种见诸于中世纪手稿的漂亮字迹。没人认为这会对他的职业生涯有帮助，包括他自己。他只是因为喜欢而学。最后却发现受益良多。麦金塔电脑（Macintosh）成就了苹果，它上市的年代，计算机刚好具备了能力把字母渲染得像纸书上一样，在此之前，你看到的是像素风格的字体，就像八位机游戏中看到的样子。苹果在这方面碾压了所有对手，部分得益于史蒂夫是计算机行业少有的懂图形设计的人。\n不要觉得你的项目必须很正经。也可以是玩票性质的，只要你是在打造让自己激动的东西。也许百分之九十的程序员都从写游戏开始。他们和朋友们喜欢玩游戏。所以他们要打造自己和朋友们喜欢的游戏。如果有朝一日你想创业，这就是你在十五岁时该做的事。\n你也没必要只做一个项目。实际上多学几样总是好的。史蒂夫•乔布斯不止学书法，也学电子学，电子学后来体现了更重大的价值。感兴趣就好。（抓住主旨了没？）\n这是三件事的第一件，精通一项或多项技术。和精通小提琴和足球一样的方法：练习。如果你二十二岁创立公司，并且现在开始写自己的程序，那么等你的公司开张时，你已经写了七年的代码。不管什么事情，你练习了七年，都会相当精通了。\n假设你二十二岁了，也已经成功做到：你真的精通了某项技术。如何能有一个产品创意呢？这看起来可能是个难题。就算你是个出色的程序员，你又如何能想到谷歌的创意呢？\n其实只要你精通了技术，创意并不难。只要你精通了某项技术，当你观察这个世界的时候，你会发现事物所缺失的功能。你开始能洞察到技术本身的缺憾，以及可以用这项技术来解决的问题，任何一项都足以撑起一家潜在的创业公司。\n我们家附近的镇上有一家商店，门口有一块标牌写着「门很难关上」。标牌在那已经几年了。对店里的人来说，门容易卡住就像一种神秘的自然现象，他们能做的就是竖起一块标牌提醒顾客。但任何木匠看到这种情况就会想，「为什么不刨掉卡住的地方呢？」\n一旦你精通了编程，这个世界所缺失的软件，就会像木匠眼中那扇容易卡住的门一样纷纷浮现。我来给你一个真实世界的例子。回到二十世纪，美国大学曾经会发布纸质的学生通讯录。只要我一说出这种通讯录叫什么，你马上就知道我说的是哪家创业公司。它们叫「脸书（facebooks）」，因为学生的名字旁边会放一张照片。\n所以当马克•扎克伯格 2002 年进入哈佛的时候，他们还没有在线的「脸书」。每栋楼有在线的「脸书」，但整个学校没有。学校管理部门为此频繁开会，也许再过十年就有望解决这个问题了。大多数学生没觉得有什么不对的。但马克是一名程序员。他看到这种情况就想，「好吧，有点弱。我一个晚上就能写个程序来解决它。只要让大家上传照片，然后把数据汇集到一个面向全校的新网站。」说干就干。几乎真的是一夜之间，他就有了数千用户。\n当然，脸书当时还不算创业公司。它只是一个……项目。这个词又出现了。项目不仅是练技术的最佳方式，同时也是公司创意的最佳来源。\n脸书并不是孤例。苹果和谷歌也始于项目。苹果起初并没有计划成立公司，史蒂夫•沃兹尼亚克只是想打造自己的电脑。直到有一天，史蒂夫•乔布斯说，「嘿，我在想我们能不能把这种电脑的设计图卖给别人？」，于是苹果成了一家公司。这是苹果的起步过程。那时他们甚至不卖电脑，只卖设计图。你能想象这家公司看起来有多弱吗？\n谷歌也是。拉里和谢尔盖一开始也没有创业想法。他们只是想改善搜索的体验。在谷歌之前，大多数搜索引擎不会对结果按照重要性排序。如果你搜「橄榄球」，他们就会把每个包含「橄榄球」这个词的网页呈现给你。1997 年的时候，互联网规模还很小，所以这种策略还能凑合。可能只有二三十个网页包含「橄榄球」这个词。但从那以后，互联网呈指数级增长，所以这种呈现搜索结果的方式很快就失效。多数用户会想，「哇，我必须得从一大堆搜索结果中找出我想要的。」门卡住了。但跟马克一样，拉里和谢尔盖也是程序员。跟马克一样，他们研究了情况，心想，「好吧，有点愚蠢。部分关于橄榄球的网页要比其他的更重要。我们来搞清楚哪些更重要，并把它们放在前面。」\n事后去想，这对于创业公司来说，明显是个好创意。但在当时，这并不明显。根本不明显。如果在当时，苹果、谷歌或脸书就意识到这明显是个好创意，那么早就有人把这事给做了。这就是为什么伟大的创业公司通常脱胎于无心插柳的项目。你只是凭着本能找到感兴趣的事。如果你很年轻并精通技术，那么凭无意识的本能跟着兴趣走，比挖空心思去想一个成就好公司的创意，效果更好。\n如果你是一个年轻的创始人，做自己和朋友会用的东西是至关重要的。为看不见摸不着的小众人群打造产品，是年轻创始人会犯的最严重错误。如果你能做出自己和朋友真心想使用的东西——朋友使用它并不是出于友情，而是真心离不开这个东西——那么一个好的创业创意就已经萌芽。你可能还看不出能成一个公司。盈利模式还不是那么明显。但相信我，会有办法的。\n你创业所需要的创意，就是你身边朋友需要的产品。一旦你精通技术，这些创意并不能洞察。卡住的门无处不在。2\n第三条也是最后一条：一个或多个创业伙伴。一个理想的创业公司一般有两到三个创始人，所以你需要再找一到两个。怎样才能找到？我接下来想说什么，你们能猜到吗？还是那句话：项目。你和他人一起做项目，就可能找到创业伙伴。你所需要的创业伙伴，他要精通自己手上的事，能和你紧密合作，判断这些特质的唯一方法就是跟他们一起做项目。\n到这里，我要讲点你们可能不爱听的话。成绩很重要，哪怕是那些死记硬背的课或废话连篇的文学。因为进好大学必须要有好成绩。如果你想创业，尽全力考上你能进的最好的大学，因为最好的创业伙伴就在那儿。最好的员工也在那儿。拉里和谢尔盖成立谷歌时，他们录用了在斯坦福认识的最聪明的一群人，这真的是一个优势。\n经验证据也支持此观点。如果你关注一下大量的优秀创业公司出自哪里，很可能出自那些要求最高的大学。\n我认为并不是那些大学的卓越声誉催生了更多的优秀创业公司。也不是因为它们的教育质量更高。真正的原因是这些大学的门槛很高。想进麻省理工或剑桥，你必须聪明、有决心。所以，如果你成功入学了，你会发现其他同学里面有相当一部分人也一样聪明、有决心。3\n你并不一定要跟大学同学一起创业。Twitch 的两个创始人七岁时就认识了。Stripe 的创始人，帕特里克和约翰克里森，在约翰出生时就相遇了。但是，大学确实是创业伙伴的主要来源。并且，正因为创业伙伴出自于大学，创意也出自于此，因为最佳创意通常是从你们一起做的项目中诞生的。\n所以，从现在到开始创业，你需要做的事情很简单。你需要以做个人项目的方式，来精通某项技术。同时尽量在学校取得好成绩，争取进入好大学，因为你的创业伙伴和创意都在那里。\n就这样，两件事，捣鼓点东西，好好学习。\n译者注：原文是“I mean I\u0026rsquo;m going to tell you how to get to the point where you can start a company that has as much chance of being Google as Google had of being Google.”，此处原为作者注，作者对本句话中的两个 Google 做了解释，已经在译文中体现。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n给你的朋友做点东西，并不是创意的唯一来源。但它是年轻创业者的最佳创意来源，因为他们对其他人的需求知之甚少，但他们自己的需求却能预见未来。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n很奇怪，在美国这样本科招生工作做得很差的国家，这一规律却尤其明显。美国招生部门让申请者为了各种随心所欲的要求疲于奔命，而这些要求跟他们的智力都没关系。考试越随机，越能考验一个人的决心和应变能力。而这是创业者最重要的两项品质。所以，美国招生部门如果选拔的是好学生，他们可能会错失优秀的创业者。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"四月 29, 2024","permalink":"/posts/paul-graham/how-to-start-google/","section":"文章","summary":"Paul Graham 给孩子们的创业建议","title":"【Paul Graham】如何创立谷歌那样的公司"},{"content":"","date":null,"permalink":"/series/paul-graham/","section":"系列","summary":"","title":"Paul Graham"},{"content":"","date":null,"permalink":"/tags/%E8%AF%91%E6%96%87/","section":"标签","summary":"","title":"译文"},{"content":"前言 #作为一个软件工程师，提升自己能力的最重要的手段之一是读书。资深的工程师需要防止自己能力的腐化，防止自己代码的腐化，通过不断读书来补齐知识的短板。新加入职场的工程师，前面几年更应该是大量密集读书的时期，多花一些业余的时间，从一开始就树立对软件开发的正确认知，价值回报会伴随整个职业生涯。\n通过陈列一个书单，希望能够帮助大家大致梳理下软件开发的知识脉络，有针对性地去加强和巩固自己的知识，也作为我自己的总结。对于经验丰富的工程师，也强烈建议大家继续学习。以下推荐的书籍，至少我都读过，有些可能是挑着章节读的，少数没读过的都会单独说明。\n希望把这篇文章一直更新下去，不断加入更新更高质量的书籍。\n我们从两个维度来评价每本书籍：\n推荐度：代表作者对书的价值的主观评价，1～5分，越高代表越有价值。\n优先级：代表读这本书的紧急程度（尤其针对新人），1～5分，越小代表越早读。\n对于读书，还有几点建议。\n重视基础知识 #软件开发正在变成一个工具学科，几乎所有的行业，都需要软件工程师；同时它又是一门很复杂的工具学科。这是一个利好，这决定了我们的职业生涯具有广阔的前景。但是，支持我们兑现自己职业生涯广阔前景的，是基础知识是否扎实，而不掌握了多少新鲜的名词。学会分辨哪些知识是易变，哪些知识是不变的。恰恰是不变的东西，没多少人学得好。\n尽量读英文原版 #中文书籍的出版经常会滞后于英文原版几年，读英文原版能确保我们读到最新的版本。大部分计算机书籍的中文翻译质量也不好，有时候比英文更难理解。更重要的一点，我们需要信息自由。当我们阅读英文的速度能接近母语的时候，会感觉无比自由。\n发现真正的问题，并用学到的软件知识去解决 #Dennis Ritchie 说过：\nThe only way to learn a new programming language is by writing programs in it.\n把书本知识转化固化为内在的认知，一定要做真正的项目。这个项目不一定是你的工作职责给你的任务。生活和工作中有大量可以使用软件去解决的问题，尝试发现这些问题（比如帮助同事处理一个表格），然后去解决它。在解决过程中，会产生更深刻的认知。\n本文以建设我当前工作团队的能力为目标，以建设基础能力为主，以实用为主，不准备做到面面俱到，适用的对象可能是从事系统编程和嵌入式编程的工程师。有不少计算机方面重要著作，跟当前工作相关性不大，就不一一介绍。\nC #The C Programming Language, 2nd Edition #C 语言是一门「简单」的语言，如果要推荐一本正统的教程，就是这本。这是 C 语言作者写的书。没有系统学习过C语言的同学，可以通过这本书来学习。学校里如果学过，可以作为参考书。 这本书的缺憾是以 C89 为标准写的，而且两位作者一位已经去世多年，另一位也已近暮年，以后也不会再更新了。但 C99 的新特性可以通过互联网上的其他资料来弥补。\n推荐度：3 优先级：1 C-FAQ #https://c-faq.com\nC-FAQ 收集了从远古时代至今的在comp.lang.c新闻组中被问到的最重要问题。强烈推荐读一遍。\n推荐度：3 优先级：2 C Traps and Pitfalls #C 语言是一门「简单」的语言，「简单」的意思是，把刀子递到你手里，你怎么用是你自己的事情。这个文档是一篇论文，后来发展成了一本书。其实只要看论文就可以了。它的关注点是 C 语言的阴暗面，那些容易犯错的地方。\n推荐度：3 优先级：2 C++ #C++ Primer, 5th Edition #这是公认的最好的 C++ 入门书，C++ 标准委员会权威专家的著作。虽然说是「入门书」，但它的内容非常详尽，周边材料也比较齐全。这本书的编排，跟一般书思路有点不一样，注重实用再逐步深入，所以把常见 STL 的介绍放在比较靠前的章节。对于真正要入门的同学来说，可以挑着读。如果按照常见的 C++ 教学思路，可以先读 Part I 和 Part III（最后一章泛型也可以先不看），对 C++ 语言特性有一个较为全面的了解，就可以利用手上的技能在工作中去做一些实际的事情了，逐步再去学习 STL 和其他高级主题。\n这本书的更新也相对较慢，目前最新版是针对 C++ 11，略有点老。新的第 6 版也在规划中，但出版日期一直不确定（作者之一 Stanley Lippman 已于 2022 年去世）。不过 C++ 14 和 17 的新特性，也可以通过其他的一些补充材料去学习。\n推荐度：4 优先级：1 The C++ Programming Language, 4th Edition #这是 C++ 之父的著作，权威程度不言而喻，内容上也是最全的，一千三百多页。也只讲到 C++ 11。这本书我的个人感受是不如 C++ Primer 好懂，没看完。两者读一本就可以。\n推荐度：3 优先级：1 Effective C++ \u0026amp; Effective Modern C++ #来自 Scott Meyers 的 C++ 著作，不关注完整的 C++ 特性，而是关注如何写出高效的 C++ 程序。先读 Effective C++，再读 Effective Modern C++，两本书没有替代关系，是互补的。第一本讲的是通用的 C++ 特性，但不排除某些观点已经过时，第二本专注于 C++ 11 和 14 带来的新特性。\n推荐度：4 优先级：2 C++ Core Guidelines #https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\n官方建议的 C++ 编程的核心原则，由 C++ 之父 Bjarne Stroustrup 和 C++ 标准委员会主席 Herb Sutter 维护。强烈推荐看一遍，很多疑问都可以找到答案。\n推荐度：4 优先级：1 计算机系统 #你可能会发现你 C 语言学得再熟，写出来的程序问题还是很多，你的瓶颈在于你不理解计算机系统是如何工作的。\nComputer System - A Programmer\u0026rsquo;s Perspective, 3rd Edition（深入理解计算机系统） #这本书的中文名翻译成《深入理解计算机系统》，有点意译的成份。书名的本意是从程序员的视角去看计算机系统，也就是那些能帮助程序员写出好程序的计算机系统知识。这些知识的更新并不快，但真正敢说掌握的人，很少。我经常在面试中会问负数的二进制表示法以及这么设计的理由，能答上来的人不会超过一半。\n这本书蕴含了软件开发过程中非常重要的一种思维方式：像计算机一样去思考——反复问自己，我写出来的程序，对计算机来说，究竟意味着什么？这本书能给你一个系统性的答案。\n我刚开始工作的时候，这本书几乎没人知道，现在都已经被很多国内大学作为教材了，但这本书很厚，学校能教多少内容就不好说了。\n推荐度：5 优先级：2 A Primer on Memory Consistency and Cache Coherence, 2nd Edition #https://pages.cs.wisc.edu/~markhill/papers/primer2020_2nd_edition.pdf\n讲清楚内存模型和缓存一致性协议的最好的书。曾经在公司级的代码质量委员会中听人抱怨，面试的候选人里面，几乎没有人听说过内存模型这个概念。就是这本书了。\n推荐度：4 优先级：3 What Every Programmer Should Know About Memory #https://people.freebsd.org/~lstewart/articles/cpumemory.pdf\n这是 Red Hat 工程师 Ulrich Drepper 早年写的一篇长论文，解释内存和缓存是如何工作的，这是我见过最好的讲内存知识的资料。跟上一本书同样的意义，从软件的视角看计算机系统，从计算机系统的视角看软件，割裂了两者，写不好程序。\n推荐度：4 优先级：3 操作系统 #我们写不好程序的另一个原因可能是不理解操作系统的工作原理。学习操作系统，大量的开源操作系统源码是最好的资料，但书能起到知识梳理的作用，让你能更好地理解源码。理论类的选一本读就够了。\nModern Operating System, 4th Edition（现代操作系统） #操作系统的畅销书有不少，这是其中一本，优点是比较新，里面讲到了 Windows 8、Android、VMware 等传统操作系统书不会讲的内容。\n推荐度：4 优先级：2 The Linux Kernel Module Programming Guide #https://sysprog21.github.io/lkmpg\n二十年前学 Linux 驱动编程必读。是的，现在还在推荐这本古老的书，说明它复活了！有位台湾的朋友 Jim Huang 接手了，并努力把它更新到适用于最新的内核版本。\n推荐度：4 优先级：2 Linux Kernel Development, 3rd Edition（Linux内核开发） #讲 Linux 内核的书，都比较老了，这本是相对较新的。作者 Robert Love 是资深的 Linux 社区开发者。\n推荐度：3 优先级：3 linux-kernel-labs.github.io #https://linux-kernel-labs.github.io\n这份文档是布加勒斯特理工大学的操作系统教学材料，相当详尽，实操性很强，针对 Linux。\n推荐度：3 优先级：4 Linux Insides #https://0xax.gitbooks.io/linux-insides\n这是一位国外网友还在编写中的 Linux 内核书籍，但内容已经非常多了。\n推荐度：3 优先级：4 POSIX系统编程 #Advanced Programming in the UNIX Environment, 3rd Edition（UNIX环境高级编程） #这本书通常被称为 APUE，是学习类 UNIX 系统编程的不二选择。这本书历史也比较悠久，前两版的作者 Richard Stevens 不幸于1999年去世，直到2013年才有人续写了第三版。虽然是以 UNIX 系统为目标，但因为 UNIX 和 Linux 都兼容POSIX接口，所以对于学习 Linux 系统编程也是完全没有问题的。\n推荐度：4 优先级：2 Linux System Programming, 2nd Edition（Linux系统编程） #这本书同样是讲系统编程，对 Linux 的针对性更强，同样是 Robert Love 的作品。他自己对这本书的评价：这是 Linux 时代的 APUE（is Stevens for the Linux era）。\n推荐度：3 优先级：3 算法 #Algorithm, 4th Edition（算法） #我最推荐的是这本，作者是 Knuth 教授的弟子，Knuth 教授本人的书我就不推荐了，估计没几个人会有时间去读。这本书的一大特色就是注重实用，图表很详尽。示例代码是 Java。\n推荐度：4 优先级：2 Introduction to Algorithm, 3rd Edition（算法导论） #麻省理工的著名教材，重理论，数学多。用伪代码表示。我只翻过几次。\n推荐度：4 优先级：3 软件设计 #经常看代码的人会有一种感觉，为什么别人的代码设计都很精妙，而自己的代码就像小学生作文一样。你学习过面向对象设计，当书本上讲到封装、继承、多态的时候，你不停地点头，觉得好有道理哦，但放下书本写出来的程序还是一塌糊涂。\n很多时候我们会混淆工具和思想。编程语言给你的特性是工具，你可以设计一个子类来继承父类的特性并且增加自己的特性，你可以让多个不同的对象看起来是一个样子的，这些都是工具。但编程语言没法告诉你这么多对象应该如何组织、分工以及交互，设计模式能回答这些问题。\nDesign Patterns Elements of Reusable Object-Oriented Software（设计模式） #所有设计模式的其他书籍，都可以认为是这本书的衍生品。由于书籍的作者有四个人，这本书也被称为 Gang of Four。这本书的例子是用 C++ 写的，所以需要基本的 C++ 基础。有丰富编程经验的人，看这本书是最好的选择，非常简单明了。\n推荐度：5 优先级：2 Head First Design Patterns（深入浅出设计模式） #这本书是畅销的 Head First 系列，好处就是讲得很生动，对于编程经验不多的人是比较好的选择，缺点就是长。我看了一点，感觉节奏太慢了，像几十集的言情剧。\n推荐度：4 优先级：2 Test Driven Development（测试驱动开发） #TDD 是一种重要的方法论。TDD 不能帮你发现新的缺陷，但 TDD 能帮你大大改善设计。这本书是 TDD 方法论的鼻祖，得过 Jolt 大奖，整本书有大量的实例，每一章节通常只有两三页，阅读这本书的体验本身也有点 TDD 的感觉，小步快跑。这本书也已经绝版了，二手书较贵。\n推荐度：5 优先级：1 Agile Software Development, Principles, Patterns and Practices（敏捷软件开发——原则、模式与实践） #也是获 Jolt 大奖的书，早期普及敏捷开发的重要书籍。这本书的融合了设计模式、TDD、架构原则等重要主题，辅助以大量的实例代码，让我们明白敏捷最重要的事情是设计出可以让我们敏捷起来的软件。\n这本书已经很难买到了，二手的价格偏高。\n推荐度：4 优先级：2 计算机网络 #Computer Networks（计算机网络） #我上大学时代的计算机网络教材的不二选择，不知道现在还用不用。基于 OSI 七层模型来阐述。和前面的 Modern Operating System 同样来自 Tanebaum 教授。\n推荐度：3 优先级：2 TCP/IP Illustrated Volume 1（TCP/IP详解） #来自已故大师 Richard Stevens 的另一本大作，想起了我刚毕业那几年。时隔很多年，也是由其他人又更新了一版。这本书专注TCP/IP。\n这本书还有 Volume 2，专讲实现。一千多页的书，没有人再为它更新了 T_T。\n推荐度：4 优先级：3 工具 #Pro Git, 2nd Edition #https://git-scm.com/book/en/v2\n这本书是 Git 官方推荐的书籍，它本身也是个开源项目，处于不断更新中，官网的 pdf 下载链接会定期更新，也可以下载项目的源码自己编译出最新的 pdf。\nGit 已经不仅仅是一个版本管理工具，已经成为一种管理数据的通用手段。做软件开发的人，对Git必须非常熟悉。我们鼓励大家跟着这本书，使用命令行工具 Git 来一步步学习，养成使用原生软件的习惯。我们可以接受大家使用各种带 GUI 的二手 Git 工具，但我们会按照原生 Git 工具能达成的结果去设定要求和规范，而不会关心二手的工具能做哪些不能做哪些。\n推荐度：5 优先级：1 管理 #The Mythical Man Month（人月神话） #对于软件项目的管理，无论如何都绕不开这本书。在写这篇文档的时候，作者Brooks教授刚去世三周。这本书提出了一些时隔四十几年后依然很重要的观点，比如：什么情况下给项目加人是可以加快进度的，什么情况下加人会适得其反；为了保证设计的一致性，开发团队的角色应该如何设置；以及最终的结论——没有银弹。\n推荐度：3 优先级：3 其他好书（未整理） #The Joy of Cryptography #https://joyofcryptography.com\n这是一本很新的密码学教材。\nA Graduate Course in Applied Cryptography #http://toc.cryptobook.us\n斯坦福的教材，免费的书，虽然名字看起来很土，但内容非常详尽，而且难能可贵的是，非常新，持续更新中。\nAlgorithms (by Jeff Erickson) #http://jeffe.cs.illinois.edu/teaching/algorithms/\n高级算法教程，需要有基础算法的基础。\nIntroduction to Applied Linear Algebra – Vectors, Matrices, and Least Squares #https://web.stanford.edu/~boyd/vmls/\n斯坦福大学的线性代数教程。\nLinear Algebra Done Right #https://linear.axler.net\n又一本线性代数。\nIs Parallel Programming Hard, And, If So, What Can You Do About It? #https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html\n又是一本很厉害的书，讲并发的。近千页。更新很勤。作者 Paul McKenney 是并发领域的专家，Linux RCU 实现的维护者。\nRust Atomics and Locks #https://marabos.nl/atomics/\n关于 Rust 的 原子操作和锁的书，Paul McKenney 作序。\nModern CPP Programming #https://github.com/federico-busato/Modern-CPP-Programming\nNvidia 工程师 Federico Busato 写的 C++ 教程，持续更新，以精美的幻灯片形式呈现。\nA Philosophy of Software Design, 2nd Edition #https://web.stanford.edu/~ouster/cgi-bin/book.php\n斯坦福教授 John Ousterhout 写的关于软件设计的书，不少人推荐作为 Clean Code 的替换。John Ousterhout 还是 Tcl 编程语言的发明者。\n去哪里买绝版书 #多抓鱼是一个二手流转平台（有 App 和微信小程序），应该说大部分书都能找到，但抢手的二手书需要等，可以注册一个到货通知，但也不一定抢得过别人。可以预定，但需要支付多抓鱼专用的积分——「鱼」，获取「鱼」先要卖抢手的书给多抓鱼。\n淘宝有少量的二手书商，偶尔能淘到想要的正版二手书，基本看运气。\n对于有高质量电子版的绝版书，可以找淘宝上的打印商打印和装订，质量很高，价格很便宜，一本 200 页的书不到 20 元，还可以用道林纸。这是盗版行为，不鼓励，但如果已经决定了要买盗版，这种途径的质量远远好于印刷厂翻印的。\n","date":"四月 20, 2023","permalink":"/posts/cs-books/","section":"文章","summary":"给嵌入式软件工程师的读书指南","title":"我们读什么计算机书"},{"content":"","date":"一月 1, 0001","permalink":"/about/","section":"尼普学种花","summary":"","title":""},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"标签","summary":"","title":"标签"},{"content":"","date":null,"permalink":"/posts/","section":"文章","summary":"","title":"文章"},{"content":"","date":null,"permalink":"/series/","section":"系列","summary":"","title":"系列"}]